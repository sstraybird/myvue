{"version":3,"file":"vue.js","sources":["../src/state.js","../src/init.js","../src/index.js"],"sourcesContent":["\r\nexport function initState(vm) { // 状态的初始化\r\n    const opts = vm.$options;\r\n    console.log(\"initSate\",opts)\r\n}\r\n","//插件一般都是一个函数，需要调用一下才能用\r\n\r\nimport {initState} from \"./state\";\r\n\r\nexport function initMixin(Vue) {        //这里的Vue是VUe构造函数\r\n    Vue.prototype._init = function(options) {\r\n        console.log(options);\r\n        const vm = this     //this 都是指原型的实例 就是在index.html new出的vm   这里赋值给vm方便阅读 var that = this;\r\n        vm.$options = options    // 后面会对options进行扩展操作\r\n\r\n        // 对数据进行初始化 watch computed props data ...\r\n        initState(vm); // vm.$options.data  数据劫持\r\n    }\r\n}","import { initMixin } from \"./init\";\n\nfunction Vue(options) {     //构造函数模拟类，类中写prototype比较怪，用function符合习惯\n    // options 为用户传入的选项\n    this._init(options); // 创造一个实列进行初始化操作，核心操作， 组件也需要初始化，组件也应该有个_init方法,所以把_init变成公共方法，_表示私有，约定，\n                        //this 谁new 就是谁，实例上在initMixin上加了_init方法\n}\n\n//拆分，把不同的功能拆分到不同的文件中，通过注入的方式来使用\n// 扩展原型的，\ninitMixin(Vue);     //在原型上添加_init方法， 组件也需要初始化，组件也应该有个_init方法,所以把_init变成公共方法\n\nexport default Vue    //导出的会放到window下"],"names":["initState","vm","opts","$options","console","log","initMixin","Vue","prototype","_init","options"],"mappings":";;;;;;IACO,SAASA,SAAS,CAACC,EAAE,EAAE;;MAC1B,IAAMC,IAAI,GAAGD,EAAE,CAACE,QAAQ;MACxBC,OAAO,CAACC,GAAG,CAAC,UAAU,EAACH,IAAI,CAAC;IAChC;;ICJA;IAIO,SAASI,SAAS,CAACC,GAAG,EAAE;;MAC3BA,GAAG,CAACC,SAAS,CAACC,KAAK,GAAG,UAASC,OAAO,EAAE;QACpCN,OAAO,CAACC,GAAG,CAACK,OAAO,CAAC;QACpB,IAAMT,EAAE,GAAG,IAAI;QACfA,EAAE,CAACE,QAAQ,GAAGO,OAAO;;;QAGrBV,SAAS,CAACC,EAAE,CAAC,CAAC;OACjB;IACL;;ICXA,SAASM,GAAG,CAACG,OAAO,EAAE;;;MAElB,IAAI,CAACD,KAAK,CAACC,OAAO,CAAC,CAAC;;IAExB;;IAEA;IACA;IACAJ,SAAS,CAACC,GAAG,CAAC,CAAC;;;;;;;;;"}