{"version":3,"file":"vue.js","sources":["../src/utils.js","../src/observer/index.js","../src/state.js","../src/init.js","../src/index.js"],"sourcesContent":["export function isFunction(val) {\n    return typeof val === 'function';\n}\n\nexport function isObject(val) {\n    return typeof val == 'object' && val !== null\n\n}","import {isObject} from \"../utils\";\r\n\r\nexport function observe(data) {\r\n    // 如果是对象才观测\r\n    if (!isObject(data)) {\r\n        return;\r\n    }\r\n    // 默认最外层的data必须是一个对象\r\n    console.log(\"observeData\",data)\r\n}","import {isFunction} from \"./utils\";\r\nimport { observe } from \"./observer/index\"; // node_resolve_plugin\r\n\r\nexport function initState(vm) { // 状态的初始化\r\n    const opts = vm.$options;\r\n    console.log(\"initSate\",opts)\r\n    if (opts.data) {\r\n        initData(vm);\r\n    }\r\n    // if(opts.computed){\r\n    //     initComputed();\r\n    // }\r\n    // if(opts.watch){\r\n    //     initWatch();\r\n    // }\r\n}\r\n\r\nfunction initData(vm) { //\r\n    let data = vm.$options.data; // vm.$el  vue 内部会对属性检测如果是以$开头 不会进行代理\r\n    // vue2中会将data中的所有数据 进行数据劫持 Object.defineProperty\r\n    data = vm._data = isFunction(data) ? data.call(vm) : data;//data可能是函数或者对象\r\n    console.log(\"data\",data)\r\n\r\n    observe(data);\r\n}\r\n","//插件一般都是一个函数，需要调用一下才能用\r\n\r\nimport {initState} from \"./state\";\r\n\r\nexport function initMixin(Vue) {        //这里的Vue是VUe构造函数\r\n    Vue.prototype._init = function(options) {\r\n        console.log(options);\r\n        const vm = this     //this 都是指原型的实例 就是在index.html new出的vm   这里赋值给vm方便阅读 var that = this;\r\n        vm.$options = options    // 后面会对options进行扩展操作\r\n\r\n        // 对数据进行初始化 watch computed props data ...\r\n        initState(vm); // vm.$options.data  数据劫持\r\n    }\r\n}","import { initMixin } from \"./init\";\n\nfunction Vue(options) {     //构造函数模拟类，类中写prototype比较怪，用function符合习惯\n    // options 为用户传入的选项\n    this._init(options); // 创造一个实列进行初始化操作，核心操作， 组件也需要初始化，组件也应该有个_init方法,所以把_init变成公共方法，_表示私有，约定，\n                        //this 谁new 就是谁，实例上在initMixin上加了_init方法\n}\n\n//拆分，把不同的功能拆分到不同的文件中，通过注入的方式来使用\n// 扩展原型的，\ninitMixin(Vue);     //在原型上添加_init方法， 组件也需要初始化，组件也应该有个_init方法,所以把_init变成公共方法\n\nexport default Vue    //导出的会放到window下"],"names":["isFunction","val","isObject","observe","data","console","log","initState","vm","opts","$options","initData","_data","call","initMixin","Vue","prototype","_init","options"],"mappings":";;;;;;;;;;;;;;;;EAAO,SAASA,UAAU,CAACC,GAAG,EAAE;IAC5B,OAAO,OAAOA,GAAG,KAAK,UAAU;EACpC;EAEO,SAASC,QAAQ,CAACD,GAAG,EAAE;IAC1B,OAAO,QAAOA,GAAG,KAAI,QAAQ,IAAIA,GAAG,KAAK,IAAI;EAEjD;;ECLO,SAASE,OAAO,CAACC,IAAI,EAAE;;IAE1B,IAAI,CAACF,QAAQ,CAACE,IAAI,CAAC,EAAE;MACjB;;;IAGJC,OAAO,CAACC,GAAG,CAAC,aAAa,EAACF,IAAI,CAAC;EACnC;;ECNO,SAASG,SAAS,CAACC,EAAE,EAAE;;IAC1B,IAAMC,IAAI,GAAGD,EAAE,CAACE,QAAQ;IACxBL,OAAO,CAACC,GAAG,CAAC,UAAU,EAACG,IAAI,CAAC;IAC5B,IAAIA,IAAI,CAACL,IAAI,EAAE;MACXO,QAAQ,CAACH,EAAE,CAAC;;;;;;;;EAQpB;;EAEA,SAASG,QAAQ,CAACH,EAAE,EAAE;;IAClB,IAAIJ,IAAI,GAAGI,EAAE,CAACE,QAAQ,CAACN,IAAI,CAAC;;IAE5BA,IAAI,GAAGI,EAAE,CAACI,KAAK,GAAGZ,UAAU,CAACI,IAAI,CAAC,GAAGA,IAAI,CAACS,IAAI,CAACL,EAAE,CAAC,GAAGJ,IAAI,CAAC;IAC1DC,OAAO,CAACC,GAAG,CAAC,MAAM,EAACF,IAAI,CAAC;IAExBD,OAAO,CAACC,IAAI,CAAC;EACjB;;ECxBA;EAIO,SAASU,SAAS,CAACC,GAAG,EAAE;;IAC3BA,GAAG,CAACC,SAAS,CAACC,KAAK,GAAG,UAASC,OAAO,EAAE;MACpCb,OAAO,CAACC,GAAG,CAACY,OAAO,CAAC;MACpB,IAAMV,EAAE,GAAG,IAAI;MACfA,EAAE,CAACE,QAAQ,GAAGQ,OAAO;;;MAGrBX,SAAS,CAACC,EAAE,CAAC,CAAC;KACjB;EACL;;ECXA,SAASO,GAAG,CAACG,OAAO,EAAE;;;IAElB,IAAI,CAACD,KAAK,CAACC,OAAO,CAAC,CAAC;;EAExB;;EAEA;EACA;EACAJ,SAAS,CAACC,GAAG,CAAC,CAAC;;;;;;;;;"}